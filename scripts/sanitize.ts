#!/usr/bin/env npx tsx

import { execSync } from "child_process"
import { copyFileSync, existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "fs"
import { glob } from "glob"
import { dirname, join } from "path"
import * as readline from "readline"

interface SanitizeConfig {
  publicRepoUrl: string
  branchName: string
  filesToExclude: string[]
  patternsToRemove: string[]
  contentToSanitize: string[]
  gitConfig: {
    userName: string
    userEmail: string
  }
  commitMessage: string
}

class RepositorySanitizer {
  private config: SanitizeConfig
  private privateRepoPath: string
  private tempDir: string
  private publicRepoPath: string

  constructor() {
    this.privateRepoPath = process.cwd()
    this.tempDir = `/tmp/ratgarden-sanitized-${Date.now()}`
    this.publicRepoPath = join(this.tempDir, "RatGarden")

    this.config = this.loadConfig()
  }

  private loadConfig(): SanitizeConfig {
    const configPath = join(this.privateRepoPath, "scripts", "sanitize-config.json")

    if (existsSync(configPath)) {
      const configData = JSON.parse(readFileSync(configPath, "utf8"))
      return {
        publicRepoUrl: configData.publicRepoUrl || "git@github.com:samlazrak/Digital-Garden.git",
        branchName: configData.branchName || "main",
        filesToExclude: configData.filesToExclude || [],
        patternsToRemove: configData.patternsToRemove || [],
        contentToSanitize: configData.contentToSanitize || [],
        gitConfig: {
          userName: configData.gitConfig?.userName || "RatGarden Sanitizer",
          userEmail: configData.gitConfig?.userEmail || "sanitizer@ratgarden.local",
        },
        commitMessage: configData.commitMessage || "Sanitized version for public showcase",
      }
    }

    // Default configuration
    return {
      publicRepoUrl: "git@github.com:samlazrak/Digital-Garden.git",
      branchName: "main",
      filesToExclude: [
        "api/ai-assistant.js",
        "private/",
        ".env*",
        "*.env",
        ".vscode/",
        ".claude/",
        ".idea/",
        "debug_*.cjs",
        "test_*.cjs",
        "debug_*.css",
        "debug_*.js",
        "homebrew.mxcl.quartz.plist",
        "setup-launchagent.sh",
        "CLAUDE.md",
        "CURSOR.md",
        "DRAFT_MANAGEMENT.md",
        "package-lock.json",
        ".npmrc",
        ".node-version",
        "vercel.json",
        ".env.example",
        "api/",
        "tests/",
        "quartz/components/__tests__/",
        "content/docs/ai-features-documentation.md",
        "content/blog/ai-features-showcase.md",
        "content/blog/nvidia-computer-vision-projects.md",
        "content/demos/ai-interactive-demos.md",
        "content/art/Ritual - Essential Grimoire.md",
        "node_modules/",
        "public/",
        ".quartz-cache/",
        "coverage/",
        ".nyc_output/",
        "temp/",
        "tmp/",
        "*.log",
        "*.tgz",
        "tsconfig.tsbuildinfo",
        "*.key",
        "*.pem",
        "*.p12",
        "*.pfx",
        "*.crt",
        "*.cert",
        "config.json",
        "secrets.json",
        "credentials.json",
      ],
      patternsToRemove: [
        "api_key",
        "apiKey",
        "API_KEY",
        "secret",
        "password",
        "token",
        "OPENAI_API_KEY",
        "ANTHROPIC_API_KEY",
        "sk-[a-zA-Z0-9]*",
        "sk-ant-[a-zA-Z0-9]*",
      ],
      contentToSanitize: ["content/docs/ai-features-documentation.md"],
      gitConfig: {
        userName: "RatGarden Sanitizer",
        userEmail: "sanitizer@ratgarden.local",
      },
      commitMessage:
        "Sanitized version for public showcase\n\n- Removed draft posts and private content\n- Sanitized configuration files\n- Removed API keys and sensitive data\n- Updated README for public consumption\n\nGenerated by sanitize.ts",
    }
  }

  private log(message: string, type: "info" | "success" | "warning" | "error" = "info"): void {
    const colors = {
      info: "\x1b[34m",
      success: "\x1b[32m",
      warning: "\x1b[33m",
      error: "\x1b[31m",
      reset: "\x1b[0m",
    }

    const prefix = {
      info: "[INFO]",
      success: "[SUCCESS]",
      warning: "[WARNING]",
      error: "[ERROR]",
    }

    console.log(`${colors[type]}${prefix[type]}${colors.reset} ${message}`)
  }

  private async createTempDirectory(): Promise<void> {
    this.log("Creating temporary directory...")
    mkdirSync(this.tempDir, { recursive: true })
  }

  private async copyFilesSelectively(): Promise<void> {
    this.log("Copying files selectively to public repository...")

    // Get all files in the private repo (not directories)
    const allFiles = await glob("**/*", {
      cwd: this.privateRepoPath,
      ignore: ["node_modules/**", ".git/**", ...this.config.filesToExclude],
      dot: true,
      nodir: true, // Only files, not directories
    })

    // Copy each file that should be included
    for (const file of allFiles) {
      const sourcePath = join(this.privateRepoPath, file)
      const destPath = join(this.publicRepoPath, file)

      // Create destination directory if it doesn't exist
      mkdirSync(dirname(destPath), { recursive: true })

      // Copy the file
      copyFileSync(sourcePath, destPath)
    }
  }

  private createEnhancedGitignore(): void {
    this.log("Creating enhanced .gitignore for public repository...")

    const gitignoreContent = `# Enhanced exclusions for public repository
# Environment files and secrets
.env
.env.*
*.env
secrets/
secret/
private/
private-keys/
api-keys/

# IDE and development-specific directories (keep in private repo only)
.vscode/
.claude/
.idea/

# Development and debug files
debug_*.cjs
test_*.cjs
debug_*.css
debug_*.js
homebrew.mxcl.quartz.plist
setup-launchagent.sh

# Internal documentation and conversation logs
CLAUDE.md
CURSOR.md
DRAFT_MANAGEMENT.md

# Sensitive configuration files
package-lock.json
.npmrc
.node-version
vercel.json
.env.example

# Temporary files
temp/
tmp/

# Cache directories
.cache/
cache/

# Local configuration files
config.local.*
*.local.*

# Backup files
*.bak
*.backup
*~

# Test files that might contain sensitive data
test-secrets.*
*secret*.test.*

# Additional security exclusions
*.key
*.pem
*.p12
*.pfx
*.crt
*.cert
config.json
secrets.json
credentials.json

# API and sensitive files
api/ai-assistant.js
api/

# Content that should not be public
content/docs/ai-features-documentation.md
content/blog/ai-features-showcase.md
content/blog/nvidia-computer-vision-projects.md
content/demos/ai-interactive-demos.md
content/art/Ritual - Essential Grimoire.md

# Test files
tests/
quartz/components/__tests__/

# Build and cache files
public/
.quartz-cache/
prof/
node_modules/
coverage/
.nyc_output/
*.log
*.tgz
tsconfig.tsbuildinfo
`

    writeFileSync(join(this.publicRepoPath, ".gitignore"), gitignoreContent)
  }

  private async sanitizeContent(): Promise<void> {
    this.log("Sanitizing content files...")

    // Find all markdown files
    const markdownFiles = await glob("**/*.md", {
      cwd: this.publicRepoPath,
      absolute: true,
    })

    for (const file of markdownFiles) {
      let content = readFileSync(file, "utf8")

      // Replace API key patterns
      content = content.replace(/sk-[a-zA-Z0-9]*/g, "sk-***")
      content = content.replace(/sk-ant-[a-zA-Z0-9]*/g, "sk-ant-***")

      // Remove lines with API key examples
      content = content
        .split("\n")
        .filter((line) => !line.includes("OPENAI_API_KEY=sk-"))
        .filter((line) => !line.includes("ANTHROPIC_API_KEY=sk-ant-"))
        .filter((line) => !line.match(/^[[:space:]]*[A-Z_]*API_KEY=sk-/))
        .join("\n")

      writeFileSync(file, content)
    }
  }

  private async initializeGitRepository(): Promise<void> {
    this.log("Initializing git repository...")

    // Change to public repo directory
    process.chdir(this.publicRepoPath)

    // Initialize git
    execSync("git init", { stdio: "inherit" })
    execSync(`git config user.name "${this.config.gitConfig.userName}"`, { stdio: "inherit" })
    execSync(`git config user.email "${this.config.gitConfig.userEmail}"`, { stdio: "inherit" })
  }

  private async addAndCommitFiles(): Promise<void> {
    this.log("Adding files to git...")
    execSync("git add .", { stdio: "inherit" })

    this.log("Creating commit...")
    const commitMessage = this.config.commitMessage.replace("{date}", new Date().toISOString())
    execSync(`git commit -m "${commitMessage}"`, { stdio: "inherit" })
  }

  private async pushToPublicRepo(): Promise<void> {
    this.log("Adding public repository as remote...")
    execSync(`git remote add public "${this.config.publicRepoUrl}"`, { stdio: "inherit" })

    this.log("Pushing to public repository...")
    execSync(`git push public main:${this.config.branchName} --force`, { stdio: "inherit" })
  }

  private cleanup(): void {
    this.log("Cleaning up temporary directory...")
    rmSync(this.tempDir, { recursive: true, force: true })
  }

  async sanitizeAndPush(dryRun: boolean = false): Promise<void> {
    try {
      this.log("Starting sanitization process...")

      if (dryRun) {
        this.log("DRY RUN MODE - No actual changes will be made")
      }

      await this.createTempDirectory()
      await this.copyFilesSelectively()
      this.createEnhancedGitignore()
      await this.sanitizeContent()

      if (!dryRun) {
        await this.initializeGitRepository()
        await this.addAndCommitFiles()

        // Wait for user confirmation before pushing
        await this.waitForUserConfirmation()
        await this.pushToPublicRepo()
        this.log("Successfully pushed sanitized version to public repository!", "success")
      } else {
        this.log("DRY RUN: Would push to public repository", "success")
        this.log(`Public repository: ${this.config.publicRepoUrl}`)
      }
    } catch (error) {
      this.log(`Error during sanitization: ${error}`, "error")
      throw error
    } finally {
      this.cleanup()
    }
  }

  private async waitForUserConfirmation(): Promise<void> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    })

    return new Promise((resolve) => {
      this.log("Sanitization complete! Repository is ready to push.", "success")
      this.log(`Public repository: ${this.config.publicRepoUrl}`, "info")
      this.log(
        "Review the sanitized content and press Enter to push, or Ctrl+C to cancel.",
        "warning",
      )

      rl.question("Press Enter to push to public repository, or Ctrl+C to cancel: ", () => {
        rl.close()
        this.log("Pushing to public repository...", "info")
        resolve()
      })
    })
  }
}

// CLI handling
async function main(): Promise<void> {
  const args = process.argv.slice(2)
  const dryRun = args.includes("--dry-run")
  const debug = args.includes("--debug")

  if (args.includes("--help")) {
    console.log("Usage: npx tsx scripts/sanitize.ts [OPTIONS]")
    console.log("Options:")
    console.log("  --dry-run    Run sanitization without pushing")
    console.log("  --debug      Enable debug output")
    console.log("  --help       Show this help message")
    process.exit(0)
  }

  if (debug) {
    console.log("Debug mode enabled")
  }

  const sanitizer = new RepositorySanitizer()
  await sanitizer.sanitizeAndPush(dryRun)
}

// Run the script
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Sanitization failed:", error)
    process.exit(1)
  })
}

export { RepositorySanitizer }
