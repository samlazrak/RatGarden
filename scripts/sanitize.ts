#!/usr/bin/env npx tsx

import { execSync } from "child_process"
import { copyFileSync, existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "fs"
import { glob } from "glob"
import { basename, dirname, join } from "path"
import * as readline from "readline"

interface SanitizeConfig {
  publicRepoUrl: string
  branchName: string
  filesToExclude: string[]
  patternsToRemove: string[]
  contentToSanitize: string[]
  gitConfig: {
    userName: string
    userEmail: string
  }
  commitMessage: string
}

class RepositorySanitizer {
  private config: SanitizeConfig
  private privateRepoPath: string
  private tempDir: string
  private publicRepoPath: string

  constructor() {
    this.privateRepoPath = process.cwd()
    this.tempDir = `/tmp/ratgarden-sanitized-${Date.now()}`
    this.publicRepoPath = join(this.tempDir, "RatGarden")

    this.config = this.loadConfig()
  }

  private loadConfig(): SanitizeConfig {
    const configPath = join(this.privateRepoPath, "scripts", "sanitize-config.json")

    if (existsSync(configPath)) {
      const configData = JSON.parse(readFileSync(configPath, "utf8"))
      return {
        publicRepoUrl: configData.publicRepoUrl || "git@github.com:samlazrak/Digital-Garden.git",
        branchName: configData.branchName || "main",
        filesToExclude: configData.filesToExclude || [],
        patternsToRemove: configData.patternsToRemove || [],
        contentToSanitize: configData.contentToSanitize || [],
        gitConfig: {
          userName: configData.gitConfig?.userName || "RatGarden Sanitizer",
          userEmail: configData.gitConfig?.userEmail || "sanitizer@ratgarden.local",
        },
        commitMessage: configData.commitMessage || "Sanitized version for public showcase",
      }
    }

    // Default configuration
    return {
      publicRepoUrl: "git@github.com:samlazrak/Digital-Garden.git",
      branchName: "main",
      filesToExclude: [
        "api/ai-assistant.js",
        "private/",
        ".env*",
        "*.env",
        ".vscode/",
        ".claude/",
        ".idea/",
        "debug_*.cjs",
        "test_*.cjs",
        "debug_*.css",
        "debug_*.js",
        "homebrew.mxcl.quartz.plist",
        "setup-launchagent.sh",
        "CLAUDE.md",
        "docs/CURSOR.md",
        "docs/DRAFT_MANAGEMENT.md",
        "runner.sh",
        "runneroutput.log",
        "package-lock.json",
        ".npmrc",
        ".node-version",
        "vercel.json",
        ".env.example",
        "api/",
        "tests/",
        "quartz/components/__tests__/",
        "content/",
        "node_modules/",
        "public/",
        ".quartz-cache/",
        "coverage/",
        ".nyc_output/",
        "temp/",
        "tmp/",
        "*.log",
        "*.tgz",
        "tsconfig.tsbuildinfo",
        "*.key",
        "*.pem",
        "*.p12",
        "*.pfx",
        "*.crt",
        "*.cert",
        "config.json",
        "secrets.json",
        "credentials.json",
        "docs/sanitization-rules.md",
        "docs/sanitization-improvements.md",
        "scripts/sanitize.ts",
        "scripts/sanitize-config.json",
      ],
      patternsToRemove: [
        "api_key",
        "apiKey",
        "API_KEY",
        "secret",
        "password",
        "token",
        "OPENAI_API_KEY",
        "ANTHROPIC_API_KEY",
        "sk-[a-zA-Z0-9]*",
        "sk-ant-[a-zA-Z0-9]*",
      ],
      contentToSanitize: [],
      gitConfig: {
        userName: "RatGarden Sanitizer",
        userEmail: "sanitizer@ratgarden.local",
      },
      commitMessage:
        "Sanitized version for public showcase\n\n- Removed draft posts and private content\n- Sanitized configuration files\n- Removed API keys and sensitive data\n- Updated README for public consumption\n\nGenerated by sanitize.ts",
    }
  }

  private log(message: string, type: "info" | "success" | "warning" | "error" = "info"): void {
    const colors = {
      info: "\x1b[34m",
      success: "\x1b[32m",
      warning: "\x1b[33m",
      error: "\x1b[31m",
      reset: "\x1b[0m",
    }

    const prefix = {
      info: "[INFO]",
      success: "[SUCCESS]",
      warning: "[WARNING]",
      error: "[ERROR]",
    }

    console.log(`${colors[type]}${prefix[type]}${colors.reset} ${message}`)
  }

  private async createTempDirectory(): Promise<void> {
    this.log("Creating temporary directory...")
    mkdirSync(this.tempDir, { recursive: true })
  }

  private async copyFilesSelectively(): Promise<void> {
    this.log("Copying files selectively to public repository...")

    // Define specific files to include (whitelist approach)
    const includeFiles = [
      // Root configuration files
      "package.json",
      "package-lock.json",
      "quartz.config.ts",
      "quartz.layout.ts",
      "tsconfig.json",
      "globals.d.ts",
      "index.d.ts",
      "README.md",
      ".gitignore",
      ".gitattributes",
      ".prettierrc",
      ".prettierignore",
      ".npmrc",
      ".node-version",
      "Dockerfile",
    ]

    // Define quartz subdirectories to include (excluding problematic ones)
    const quartzIncludeDirs = [
      "quartz/bootstrap-*.mjs",
      "quartz/build.ts",
      "quartz/cfg.ts",
      "quartz/worker.ts",
      "quartz/cli/**/*",
      "quartz/components/**/*",
      "quartz/i18n/**/*",
      "quartz/plugins/**/*",
      "quartz/processors/**/*",
      "quartz/static/**/*",
      "quartz/styles/**/*",
      "quartz/util/**/*",
    ]

    // Get all files from included directories only
    const allFiles: string[] = []

    // Define system files to explicitly exclude
    const systemFilesToExclude = [
      ".DS_Store",
      "homebrew.mxcl.quartz.plist",
      "Thumbs.db",
      "desktop.ini",
      "*.log",
      "*.tmp",
      "*.bak",
      "*.swp",
      "*.swo",
      "runner.sh",
      "runneroutput.log",
    ]

    // Add specific root files (excluding system files)
    for (const file of includeFiles) {
      const filePath = join(this.privateRepoPath, file)
      if (existsSync(filePath) && !systemFilesToExclude.includes(file)) {
        allFiles.push(file)
      }
    }

    // Add quartz files with exclusions
    for (const pattern of quartzIncludeDirs) {
      const files = await glob(pattern, {
        cwd: this.privateRepoPath,
        ignore: [
          "**/node_modules/**",
          "**/.git/**",
          "**/.quartz-cache/**",
          "**/__tests__/**",
          "**/*.test.*",
          "**/*.spec.*",
          "**/.DS_Store",
          "**/Thumbs.db",
        ],
        dot: true,
        nodir: true, // Only files, not directories
      })
      allFiles.push(...files)
    }

    // Remove duplicates
    const uniqueFiles = [...new Set(allFiles)]

    // Group files by directory for summary
    const fileGroups: Record<string, string[]> = {}
    for (const file of uniqueFiles) {
      const dir = dirname(file)
      if (!fileGroups[dir]) fileGroups[dir] = []
      fileGroups[dir].push(basename(file))
    }

    // Show summary of files being included
    console.log("\nüìÅ Files being included in public repo:")
    for (const [dir, files] of Object.entries(fileGroups)) {
      const dirName = dir === "." ? "root" : dir
      console.log(`   üìÇ ${dirName}/ (${files.length} files)`)
      if (dirName === "root" || files.length <= 5) {
        files.forEach((file) => console.log(`      ‚Ä¢ ${file}`))
      } else {
        console.log(`      ‚Ä¢ ${files.slice(0, 3).join(", ")}... and ${files.length - 3} more`)
      }
    }

    // Copy each file to the public repo
    for (const file of uniqueFiles) {
      const sourcePath = join(this.privateRepoPath, file)
      const destPath = join(this.publicRepoPath, file)

      // Create destination directory if it doesn't exist
      mkdirSync(dirname(destPath), { recursive: true })

      // Copy the file
      copyFileSync(sourcePath, destPath)
    }

    this.log(`‚úÖ Copied ${uniqueFiles.length} files to public repository`)
  }

  private createEnhancedGitignore(): void {
    this.log("Creating enhanced .gitignore for public repository...")

    const gitignoreContent = `# Enhanced exclusions for public repository
# Environment files and secrets
.env
.env.*
*.env
secrets/
secret/
private/
private-keys/
api-keys/

# IDE and development-specific directories (keep in private repo only)
.vscode/
.claude/
.idea/

# Development and debug files
debug_*.cjs
test_*.cjs
debug_*.css
debug_*.js
homebrew.mxcl.quartz.plist
setup-launchagent.sh

# Internal documentation and conversation logs
CLAUDE.md
CURSOR.md
DRAFT_MANAGEMENT.md

# Sensitive configuration files
package-lock.json
.npmrc
.node-version
vercel.json
.env.example

# Temporary files
temp/
tmp/

# Cache directories
.cache/
cache/

# Local configuration files
config.local.*
*.local.*

# Backup files
*.bak
*.backup
*~

# Test files that might contain sensitive data
test-secrets.*
*secret*.test.*

# Additional security exclusions
*.key
*.pem
*.p12
*.pfx
*.crt
*.cert
config.json
secrets.json
credentials.json

# API and sensitive files
api/ai-assistant.js
api/

# Content that should not be public
content/docs/ai-features-documentation.md
content/blog/ai-features-showcase.md
content/blog/nvidia-computer-vision-projects.md
content/demos/ai-interactive-demos.md
content/art/Ritual - Essential Grimoire.md

# Sanitization tools and documentation
docs/sanitization-rules.md
docs/sanitization-improvements.md
scripts/sanitize.ts
scripts/sanitize-config.json

# Test files
tests/
quartz/components/__tests__/

# Build and cache files
public/
.quartz-cache/
prof/
node_modules/
coverage/
.nyc_output/
*.log
*.tgz
tsconfig.tsbuildinfo
`

    writeFileSync(join(this.publicRepoPath, ".gitignore"), gitignoreContent)
  }

  private async sanitizeContent(): Promise<void> {
    this.log("Sanitizing content files...")

    // Find all markdown files
    const markdownFiles = await glob("**/*.md", {
      cwd: this.publicRepoPath,
      absolute: true,
    })

    for (const file of markdownFiles) {
      let content = readFileSync(file, "utf8")

      // Replace API key patterns
      content = content.replace(/sk-[a-zA-Z0-9]*/g, "sk-***")
      content = content.replace(/sk-ant-[a-zA-Z0-9]*/g, "sk-ant-***")

      // Remove lines with API key examples
      content = content
        .split("\n")
        .filter((line) => !line.includes("OPENAI_API_KEY=sk-"))
        .filter((line) => !line.includes("ANTHROPIC_API_KEY=sk-ant-"))
        .filter((line) => !line.match(/^[[:space:]]*[A-Z_]*API_KEY=sk-/))
        .join("\n")

      writeFileSync(file, content)
    }
  }

  private async initializeGitRepository(): Promise<void> {
    this.log("Initializing git repository...")

    // Change to public repo directory
    process.chdir(this.publicRepoPath)

    // Initialize git
    execSync("git init", { stdio: "inherit" })
    execSync(`git config user.name "${this.config.gitConfig.userName}"`, { stdio: "inherit" })
    execSync(`git config user.email "${this.config.gitConfig.userEmail}"`, { stdio: "inherit" })
  }

  /**
   * Gets the current commit message from the primary repository and sanitizes it
   * for use in the public repository. This ensures the public repo commit messages
   * reflect the actual changes being made while removing any sensitive information.
   */
  private getCurrentCommitMessage(): string {
    try {
      // Get the current commit message from the primary repo
      const currentMessage = execSync("git log -1 --pretty=format:%B", {
        cwd: this.privateRepoPath,
        encoding: "utf8",
      }).trim()

      // Sanitize the commit message for public consumption
      let sanitizedMessage = currentMessage
        .replace(/sk-[a-zA-Z0-9]*/g, "sk-***")
        .replace(/sk-ant-[a-zA-Z0-9]*/g, "sk-ant-***")
        .replace(/api_key/gi, "api_key")
        .replace(/password/gi, "password")
        .replace(/secret/gi, "secret")
        .replace(/token/gi, "token")

      // Remove lines that might contain sensitive information
      const lines = sanitizedMessage.split("\n")
      const filteredLines = lines.filter((line) => {
        const lowerLine = line.toLowerCase()
        return (
          !lowerLine.includes("api_key=") &&
          !lowerLine.includes("password=") &&
          !lowerLine.includes("secret=") &&
          !lowerLine.includes("token=") &&
          !lowerLine.includes("sk-") &&
          !lowerLine.includes("private") &&
          !lowerLine.includes("sensitive")
        )
      })

      sanitizedMessage = filteredLines.join("\n").trim()

      // If the sanitized message is empty or too short, use the default
      if (!sanitizedMessage || sanitizedMessage.length < 10) {
        return this.config.commitMessage.replace("{date}", new Date().toISOString())
      }

      // Return just the sanitized message without mentioning sanitization
      return sanitizedMessage
    } catch (error) {
      this.log(`Warning: Could not get current commit message: ${error}`, "warning")
      // Fall back to default commit message
      return this.config.commitMessage.replace("{date}", new Date().toISOString())
    }
  }

  private async addAndCommitFiles(): Promise<void> {
    this.log("Adding files to git...")
    execSync("git add .", { stdio: "inherit" })

    this.log("Creating commit...")
    const commitMessage = this.getCurrentCommitMessage()

    // Log the sanitized commit message for debugging
    if (process.argv.includes("--debug")) {
      this.log("Original commit message from primary repo:", "info")
      try {
        const originalMessage = execSync("git log -1 --pretty=format:%B", {
          cwd: this.privateRepoPath,
          encoding: "utf8",
        }).trim()
        console.log("--- Original ---")
        console.log(originalMessage)
        console.log("--- Sanitized ---")
        console.log(commitMessage)
        console.log("--- End ---")
      } catch (error) {
        this.log(`Could not show original message: ${error}`, "warning")
      }
    }

    execSync(`git commit -m "${commitMessage}"`, { stdio: "inherit" })
  }

  private async pushToPublicRepo(fastMode: boolean = false): Promise<void> {
    this.log("Adding public repository as remote...")
    execSync(`git remote add public "${this.config.publicRepoUrl}"`, { stdio: "inherit" })

    this.log("Pushing to public repository...")
    execSync(`git push public main:${this.config.branchName} --force`, { stdio: "inherit" })
  }

  private cleanup(): void {
    this.log("Cleaning up temporary directory...")
    rmSync(this.tempDir, { recursive: true, force: true })
  }

  async sanitizeAndPush(dryRun: boolean = false, fastMode: boolean = false): Promise<void> {
    try {
      this.log("Starting sanitization process...")

      if (fastMode) {
        this.log("FAST MODE: Using optimized git operations", "info")
      }

      if (dryRun) {
        this.log("DRY RUN MODE - No actual changes will be made")
      }

      await this.createTempDirectory()
      await this.copyFilesSelectively()
      this.createEnhancedGitignore()
      await this.sanitizeContent()

      if (!dryRun) {
        await this.initializeGitRepository()
        await this.addAndCommitFiles()

        // Wait for user confirmation before pushing
        if (!fastMode) {
          await this.waitForUserConfirmation()
        } else {
          await this.waitForFastModeConfirmation()
        }

        await this.pushToPublicRepo(fastMode)
        this.log("Successfully pushed sanitized version to public repository!", "success")
      } else {
        // Show commit message processing in dry run mode
        this.log("DRY RUN: Processing commit message...", "info")
        const commitMessage = this.getCurrentCommitMessage()

        if (process.argv.includes("--debug")) {
          this.log("Original commit message from primary repo:", "info")
          try {
            const originalMessage = execSync("git log -1 --pretty=format:%B", {
              cwd: this.privateRepoPath,
              encoding: "utf8",
            }).trim()
            console.log("--- Original ---")
            console.log(originalMessage)
            console.log("--- Sanitized ---")
            console.log(commitMessage)
            console.log("--- End ---")
          } catch (error) {
            this.log(`Could not show original message: ${error}`, "warning")
          }
        }

        this.log("DRY RUN: Would push to public repository", "success")
        this.log(`Public repository: ${this.config.publicRepoUrl}`)
      }
    } catch (error) {
      this.log(`Error during sanitization: ${error}`, "error")
      throw error
    } finally {
      this.cleanup()
    }
  }

  private async waitForUserConfirmation(): Promise<void> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    })

    return new Promise((resolve) => {
      this.log("Sanitization complete! Repository is ready to push.", "success")
      this.log(`Public repository: ${this.config.publicRepoUrl}`, "info")
      this.log(
        "Review the sanitized content and press Enter to push, or Ctrl+C to cancel.",
        "warning",
      )

      rl.question("Press Enter to push to public repository, or Ctrl+C to cancel: ", () => {
        rl.close()
        this.log("Pushing to public repository...", "info")
        resolve()
      })
    })
  }

  private async waitForFastModeConfirmation(): Promise<void> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    })

    return new Promise((resolve) => {
      console.log("\n" + "=".repeat(60))
      console.log("üöÄ FAST MODE SANITIZATION SUMMARY")
      console.log("=".repeat(60))

      console.log("\nüìã What will be done:")
      console.log("   ‚úÖ Exclude ALL content (private and public)")
      console.log("   ‚úÖ Exclude ALL build artifacts and cache files")
      console.log("   ‚úÖ Exclude debug and test files")
      console.log("   ‚úÖ Include only source code and configuration")
      console.log("   ‚úÖ Use Git LFS for large files")
      console.log("   ‚úÖ Use optimized git operations (--progress --no-verify)")

      console.log("\nüìÅ Files being excluded:")
      console.log("   ‚Ä¢ content/ (all your content)")
      console.log("   ‚Ä¢ public/ (build artifacts)")
      console.log("   ‚Ä¢ node_modules/ (dependencies)")
      console.log("   ‚Ä¢ .quartz-cache/ (build cache)")
      console.log("   ‚Ä¢ api/ (API files)")
      console.log("   ‚Ä¢ tests/ (test files)")
      console.log("   ‚Ä¢ scripts/ (utility scripts)")
      console.log("   ‚Ä¢ docs/ (documentation)")

      console.log("\nüìÅ Files being included:")
      console.log("   ‚Ä¢ quartz/ (Quartz framework source)")
      console.log("   ‚Ä¢ package.json & package-lock.json (dependencies)")
      console.log("   ‚Ä¢ quartz.config.ts & quartz.layout.ts (configuration)")
      console.log("   ‚Ä¢ tsconfig.json, globals.d.ts, index.d.ts (TypeScript)")
      console.log("   ‚Ä¢ README.md, CODE_OF_CONDUCT.md, LICENSE.txt (docs)")
      console.log("   ‚Ä¢ CLAUDE.md (Claude logs)")
      console.log("   ‚Ä¢ Configuration files (.gitignore, .cursorrules, etc.)")
      console.log("   ‚Ä¢ Build files (Dockerfile, vercel.json)")

      console.log(`\nüéØ Target: ${this.config.publicRepoUrl}`)
      console.log("üìä Result: Clean source-only repository")

      console.log("\n" + "=".repeat(60))

      rl.question("\nü§î Proceed with fast sanitization? (y/N): ", (answer) => {
        rl.close()
        if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
          this.log("üöÄ Proceeding with fast sanitization...", "success")
          resolve()
        } else {
          this.log("‚ùå Sanitization cancelled by user", "warning")
          process.exit(0)
        }
      })
    })
  }
}

// CLI handling
async function main(): Promise<void> {
  const args = process.argv.slice(2)
  const dryRun = args.includes("--dry-run")
  const debug = args.includes("--debug")
  const fastMode = args.includes("--fast")

  if (args.includes("--help")) {
    console.log("Usage: npx tsx scripts/sanitize.ts [OPTIONS]")
    console.log("Options:")
    console.log("  --dry-run    Run sanitization without pushing")
    console.log("  --fast       Use fast mode (skip confirmation, optimized git ops)")
    console.log("  --debug      Enable debug output")
    console.log("  --help       Show this help message")
    process.exit(0)
  }

  if (debug) {
    console.log("Debug mode enabled")
  }

  if (fastMode) {
    console.log("Fast mode enabled - using optimized git operations")
  }

  const sanitizer = new RepositorySanitizer()
  await sanitizer.sanitizeAndPush(dryRun, fastMode)
}

// Run the script
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Sanitization failed:", error)
    process.exit(1)
  })
}

export { RepositorySanitizer }
