#!/usr/bin/env npx tsx

import { execSync } from "child_process"
import { copyFileSync, existsSync, mkdirSync, readFileSync, rmSync, writeFileSync } from "fs"
import { glob } from "glob"
import { basename, dirname, join } from "path"
import * as readline from "readline"

interface SanitizeConfig {
  publicRepoUrl: string
  branchName: string
  filesToExclude: string[]
  patternsToRemove: string[]
  contentToSanitize: string[]
  gitConfig: {
    userName: string
    userEmail: string
  }
  commitMessage: string
}

class RepositorySanitizer {
  private config: SanitizeConfig
  private privateRepoPath: string
  private tempDir: string
  private publicRepoPath: string

  constructor() {
    this.privateRepoPath = process.cwd()
    this.tempDir = `/tmp/ratgarden-sanitized-${Date.now()}`
    this.publicRepoPath = join(this.tempDir, "RatGarden")

    this.config = this.loadConfig()
  }

  private loadConfig(): SanitizeConfig {
    const configPath = join(this.privateRepoPath, "scripts", "sanitize-config.json")

    if (existsSync(configPath)) {
      const configData = JSON.parse(readFileSync(configPath, "utf8"))
      return {
        publicRepoUrl: configData.publicRepoUrl || "git@github.com:samlazrak/Digital-Garden.git",
        branchName: configData.branchName || "main",
        filesToExclude: configData.filesToExclude || [],
        patternsToRemove: configData.patternsToRemove || [],
        contentToSanitize: configData.contentToSanitize || [],
        gitConfig: {
          userName: configData.gitConfig?.userName || "RatGarden Sanitizer",
          userEmail: configData.gitConfig?.userEmail || "sanitizer@ratgarden.local",
        },
        commitMessage: configData.commitMessage || "Sanitized version for public showcase",
      }
    }

    // Default configuration
    return {
      publicRepoUrl: "git@github.com:samlazrak/Digital-Garden.git",
      branchName: "main",
      filesToExclude: [
        "api/ai-assistant.js",
        "private/",
        ".env*",
        "*.env",
        ".vscode/",
        ".claude/",
        ".idea/",
        "debug_*.cjs",
        "test_*.cjs",
        "debug_*.css",
        "debug_*.js",
        "homebrew.mxcl.quartz.plist",
        "setup-launchagent.sh",
        "CLAUDE.md",
        "docs/CURSOR.md",
        "docs/DRAFT_MANAGEMENT.md",
        "runner.sh",
        "runneroutput.log",
        ".npmrc",
        ".node-version",
        "vercel.json",
        ".env.example",
        "api/",
        "tests/",
        "quartz/components/__tests__/",
        "content/",
        "node_modules/",
        "public/",
        ".quartz-cache/",
        "coverage/",
        ".nyc_output/",
        "temp/",
        "tmp/",
        "*.log",
        "*.tgz",
        "tsconfig.tsbuildinfo",
        "*.key",
        "*.pem",
        "*.p12",
        "*.pfx",
        "*.crt",
        "*.cert",
        "config.json",
        "secrets.json",
        "credentials.json",
        "docs/sanitization-rules.md",
        "docs/sanitization-improvements.md",
        "scripts/sanitize.ts",
        "scripts/sanitize-config.json",
      ],
      patternsToRemove: [
        "api_key",
        "apiKey",
        "API_KEY",
        "secret",
        "password",
        "token",
        "OPENAI_API_KEY",
        "ANTHROPIC_API_KEY",
        "sk-[a-zA-Z0-9]*",
        "sk-ant-[a-zA-Z0-9]*",
      ],
      contentToSanitize: [],
      gitConfig: {
        userName: "RatGarden Sanitizer",
        userEmail: "sanitizer@ratgarden.local",
      },
      commitMessage:
        "Source code only - quartz/ and api/ directories\n\n- Only includes quartz/ framework source code\n- Only includes api/ directory files\n- Excludes all content, scripts, docs, and other files\n- Clean source-only repository for public showcase\n\nGenerated by sanitize.ts",
    }
  }

  private log(message: string, type: "info" | "success" | "warning" | "error" = "info"): void {
    const colors = {
      info: "\x1b[34m",
      success: "\x1b[32m",
      warning: "\x1b[33m",
      error: "\x1b[31m",
      reset: "\x1b[0m",
    }

    const prefix = {
      info: "[INFO]",
      success: "[SUCCESS]",
      warning: "[WARNING]",
      error: "[ERROR]",
    }

    console.log(`${colors[type]}${prefix[type]}${colors.reset} ${message}`)
  }

  private async createTempDirectory(): Promise<void> {
    this.log("Creating temporary directory...")
    mkdirSync(this.tempDir, { recursive: true })
  }

  private async copyFilesSelectively(): Promise<void> {
    this.log("Copying files selectively to public repository...")

    // Define specific files to include (whitelist approach)
    const includeFiles = [
      // Root configuration files
      "package.json",
      "package-lock.json",
      "quartz.config.ts",
      "quartz.layout.ts",
      "tsconfig.json",
      "globals.d.ts",
      "index.d.ts",
      "README.md",
      ".gitignore",
      ".gitattributes",
      ".prettierrc",
      ".prettierignore",
      "Dockerfile",
    ]

    // Define quartz subdirectories to include (excluding problematic ones)
    const quartzIncludeDirs = [
      "quartz/bootstrap-*.mjs",
      "quartz/build.ts",
      "quartz/cfg.ts",
      "quartz/worker.ts",
      "quartz/cli/**/*",
      "quartz/components/**/*",
      "quartz/i18n/**/*",
      "quartz/plugins/**/*",
      "quartz/processors/**/*",
      "quartz/static/**/*",
      "quartz/styles/**/*",
      "quartz/util/**/*",
    ]

    // Define api subdirectories to include
    const apiIncludeDirs = ["api/**/*"]

    // Get all files from included directories only
    const allFiles: string[] = []

    // Define system files to explicitly exclude
    const systemFilesToExclude = [
      ".DS_Store",
      "homebrew.mxcl.quartz.plist",
      "Thumbs.db",
      "desktop.ini",
      "*.log",
      "*.tmp",
      "*.bak",
      "*.swp",
      "*.swo",
      "runner.sh",
      "runneroutput.log",
    ]

    // Add specific root files (excluding system files)
    for (const file of includeFiles) {
      const filePath = join(this.privateRepoPath, file)
      if (existsSync(filePath) && !systemFilesToExclude.includes(file)) {
        allFiles.push(file)
      }
    }

    // Add quartz files with exclusions
    for (const pattern of quartzIncludeDirs) {
      const files = await glob(pattern, {
        cwd: this.privateRepoPath,
        ignore: [
          "**/node_modules/**",
          "**/.git/**",
          "**/.quartz-cache/**",
          "**/__tests__/**",
          "**/*.test.*",
          "**/*.spec.*",
          "**/.DS_Store",
          "**/Thumbs.db",
        ],
        dot: true,
        nodir: true, // Only files, not directories
      })
      allFiles.push(...files)
    }

    // Add api files with exclusions
    for (const pattern of apiIncludeDirs) {
      const files = await glob(pattern, {
        cwd: this.privateRepoPath,
        ignore: [
          "**/node_modules/**",
          "**/.git/**",
          "**/.DS_Store",
          "**/Thumbs.db",
          "**/*.log",
          "**/*.tmp",
        ],
        dot: true,
        nodir: true, // Only files, not directories
      })
      allFiles.push(...files)
    }

    // Remove duplicates
    const uniqueFiles = [...new Set(allFiles)]

    // Group files by directory for summary
    const fileGroups: Record<string, string[]> = {}
    for (const file of uniqueFiles) {
      const dir = dirname(file)
      if (!fileGroups[dir]) fileGroups[dir] = []
      fileGroups[dir]!.push(basename(file))
    }

    // Show summary of files being included
    console.log("\nüìÅ Files being included in public repo:")
    for (const [dir, files] of Object.entries(fileGroups)) {
      const dirName = dir === "." ? "root" : dir
      console.log(`   üìÇ ${dirName}/ (${files.length} files)`)
      if (dirName === "root" || files.length <= 5) {
        files.forEach((file) => console.log(`      ‚Ä¢ ${file}`))
      } else {
        console.log(`      ‚Ä¢ ${files.slice(0, 3).join(", ")}... and ${files.length - 3} more`)
      }
    }

    // Copy each file to the public repo
    for (const file of uniqueFiles) {
      const sourcePath = join(this.privateRepoPath, file)
      const destPath = join(this.publicRepoPath, file)

      // Create destination directory if it doesn't exist
      mkdirSync(dirname(destPath), { recursive: true })

      // Copy the file
      copyFileSync(sourcePath, destPath)
    }

    this.log(`‚úÖ Copied ${uniqueFiles.length} files to public repository`)
  }

  private createEnhancedGitignore(): void {
    this.log("Creating enhanced .gitignore for public repository...")

    const gitignoreContent = `# Enhanced exclusions for public repository
# This is a SOURCE-ONLY repository - only quartz/ and api/ directories are included

# Environment files and secrets
.env
.env.*
*.env
secrets/
secret/
private/
private-keys/
api-keys/

# IDE and development-specific directories
.vscode/
.claude/
.idea/

# Development and debug files
debug_*.cjs
test_*.cjs
debug_*.css
debug_*.js
homebrew.mxcl.quartz.plist
setup-launchagent.sh

# Internal documentation and conversation logs
CLAUDE.md
CURSOR.md
DRAFT_MANAGEMENT.md

# Sensitive configuration files
.npmrc
.node-version
vercel.json
.env.example

# Temporary files
temp/
tmp/

# Cache directories
.cache/
cache/

# Local configuration files
config.local.*
*.local.*

# Backup files
*.bak
*.backup
*~

# Test files that might contain sensitive data
test-secrets.*
*secret*.test.*

# Additional security exclusions
*.key
*.pem
*.p12
*.pfx
*.crt
*.cert
config.json
secrets.json
credentials.json

# Content that should not be public (excluded by design)
content/
scripts/
docs/
tests/
public/
.quartz-cache/
node_modules/
coverage/
.nyc_output/
*.log
*.tgz
tsconfig.tsbuildinfo

# Sanitization tools and documentation
docs/sanitization-rules.md
docs/sanitization-improvements.md
scripts/sanitize.ts
scripts/sanitize-config.json

# Test files
quartz/components/__tests__/
`

    writeFileSync(join(this.publicRepoPath, ".gitignore"), gitignoreContent)
  }

  private async sanitizeContent(): Promise<void> {
    this.log("Sanitizing content files...")

    // Find all markdown files
    const markdownFiles = await glob("**/*.md", {
      cwd: this.publicRepoPath,
      absolute: true,
    })

    for (const file of markdownFiles) {
      let content = readFileSync(file, "utf8")

      // Replace API key patterns
      content = content.replace(/sk-[a-zA-Z0-9]*/g, "sk-***")
      content = content.replace(/sk-ant-[a-zA-Z0-9]*/g, "sk-ant-***")

      // Remove lines with API key examples
      content = content
        .split("\n")
        .filter((line) => !line.includes("OPENAI_API_KEY=sk-"))
        .filter((line) => !line.includes("ANTHROPIC_API_KEY=sk-ant-"))
        .filter((line) => !line.match(/^[[:space:]]*[A-Z_]*API_KEY=sk-/))
        .join("\n")

      writeFileSync(file, content)
    }
  }

  private async initializeGitRepository(): Promise<void> {
    this.log("Initializing git repository...")

    // Change to public repo directory
    process.chdir(this.publicRepoPath)

    // Initialize git
    execSync("git init", { stdio: "inherit" })
    execSync(`git config user.name "${this.config.gitConfig.userName}"`, { stdio: "inherit" })
    execSync(`git config user.email "${this.config.gitConfig.userEmail}"`, { stdio: "inherit" })
  }

  /**
   * Gets the current commit message from the primary repository and sanitizes it
   * for use in the public repository. This ensures the public repo commit messages
   * reflect the actual changes being made while removing any sensitive information.
   */
  private getCurrentCommitMessage(): string {
    try {
      // Get the current commit message from the primary repo
      const currentMessage = execSync("git log -1 --pretty=format:%B", {
        cwd: this.privateRepoPath,
        encoding: "utf8",
      }).trim()

      // Sanitize the commit message for public consumption
      let sanitizedMessage = currentMessage
        .replace(/sk-[a-zA-Z0-9]*/g, "sk-***")
        .replace(/sk-ant-[a-zA-Z0-9]*/g, "sk-ant-***")
        .replace(/api_key/gi, "api_key")
        .replace(/password/gi, "password")
        .replace(/secret/gi, "secret")
        .replace(/token/gi, "token")

      // Remove lines that might contain sensitive information
      const lines = sanitizedMessage.split("\n")
      const filteredLines = lines.filter((line) => {
        const lowerLine = line.toLowerCase()
        return (
          !lowerLine.includes("api_key=") &&
          !lowerLine.includes("password=") &&
          !lowerLine.includes("secret=") &&
          !lowerLine.includes("token=") &&
          !lowerLine.includes("sk-") &&
          !lowerLine.includes("private") &&
          !lowerLine.includes("sensitive")
        )
      })

      sanitizedMessage = filteredLines.join("\n").trim()

      // If the sanitized message is empty or too short, use the default
      if (!sanitizedMessage || sanitizedMessage.length < 10) {
        return this.config.commitMessage.replace("{date}", new Date().toISOString())
      }

      // Return just the sanitized message without mentioning sanitization
      return sanitizedMessage
    } catch (error) {
      this.log(`Warning: Could not get current commit message: ${error}`, "warning")
      // Fall back to default commit message
      return this.config.commitMessage.replace("{date}", new Date().toISOString())
    }
  }

  private async addAndCommitFiles(): Promise<void> {
    this.log("Adding files to git...")
    execSync("git add .", { stdio: "inherit" })

    this.log("Creating commit...")
    const commitMessage = this.getCurrentCommitMessage()

    // Log the sanitized commit message for debugging
    if (process.argv.includes("--debug")) {
      this.log("Original commit message from primary repo:", "info")
      try {
        const originalMessage = execSync("git log -1 --pretty=format:%B", {
          cwd: this.privateRepoPath,
          encoding: "utf8",
        }).trim()
        console.log("--- Original ---")
        console.log(originalMessage)
        console.log("--- Sanitized ---")
        console.log(commitMessage)
        console.log("--- End ---")
      } catch (error) {
        this.log(`Could not show original message: ${error}`, "warning")
      }
    }

    execSync(`git commit -m "${commitMessage}"`, { stdio: "inherit" })
  }

  private async pushToPublicRepo(fastMode: boolean = false): Promise<void> {
    this.log("Adding public repository as remote...")
    execSync(`git remote add public "${this.config.publicRepoUrl}"`, { stdio: "inherit" })

    this.log("Pushing to public repository...")
    execSync(`git push public main:${this.config.branchName} --force`, { stdio: "inherit" })
  }

  private cleanup(): void {
    this.log("Cleaning up temporary directory...")
    rmSync(this.tempDir, { recursive: true, force: true })
  }

  async sanitizeAndPush(dryRun: boolean = false, fastMode: boolean = false): Promise<void> {
    try {
      this.log("Starting sanitization process...")

      if (fastMode) {
        this.log("FAST MODE: Using optimized git operations", "info")
      }

      if (dryRun) {
        this.log("DRY RUN MODE - No actual changes will be made")
      }

      await this.createTempDirectory()
      await this.copyFilesSelectively()
      this.createEnhancedGitignore()
      await this.sanitizeContent()

      if (!dryRun) {
        await this.initializeGitRepository()
        await this.addAndCommitFiles()

        // Wait for user confirmation before pushing
        if (!fastMode) {
          await this.waitForUserConfirmation()
        } else {
          await this.waitForFastModeConfirmation()
        }

        await this.pushToPublicRepo(fastMode)
        this.log("Successfully pushed sanitized version to public repository!", "success")
      } else {
        // Show commit message processing in dry run mode
        this.log("DRY RUN: Processing commit message...", "info")
        const commitMessage = this.getCurrentCommitMessage()

        if (process.argv.includes("--debug")) {
          this.log("Original commit message from primary repo:", "info")
          try {
            const originalMessage = execSync("git log -1 --pretty=format:%B", {
              cwd: this.privateRepoPath,
              encoding: "utf8",
            }).trim()
            console.log("--- Original ---")
            console.log(originalMessage)
            console.log("--- Sanitized ---")
            console.log(commitMessage)
            console.log("--- End ---")
          } catch (error) {
            this.log(`Could not show original message: ${error}`, "warning")
          }
        }

        this.log("DRY RUN: Would push to public repository", "success")
        this.log(`Public repository: ${this.config.publicRepoUrl}`)
      }
    } catch (error) {
      this.log(`Error during sanitization: ${error}`, "error")
      throw error
    } finally {
      this.cleanup()
    }
  }

  private async waitForUserConfirmation(): Promise<void> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    })

    return new Promise((resolve) => {
      console.log("\n" + "=".repeat(80))
      console.log("‚ö†Ô∏è  WARNING: ABOUT TO PUSH TO PUBLIC REPOSITORY")
      console.log("=".repeat(80))

      console.log("\nüö® IMPORTANT:")
      console.log("   ‚Ä¢ This will push ONLY quartz/ and api/ directories")
      console.log("   ‚Ä¢ ALL content, scripts, docs, and other files will be EXCLUDED")
      console.log("   ‚Ä¢ This is a SOURCE-ONLY repository")
      console.log("   ‚Ä¢ No personal content, drafts, or private files will be included")

      console.log("\nüìÅ What's being included:")
      console.log("   ‚úÖ quartz/ (Quartz framework source code)")
      console.log("   ‚úÖ api/ (API-related files)")
      console.log("   ‚úÖ Essential config files (package.json, tsconfig.json, etc.)")

      console.log("\nüìÅ What's being EXCLUDED:")
      console.log("   ‚ùå content/ (all your content)")
      console.log("   ‚ùå scripts/ (utility scripts)")
      console.log("   ‚ùå docs/ (documentation)")
      console.log("   ‚ùå tests/ (test files)")
      console.log("   ‚ùå public/ (build artifacts)")
      console.log("   ‚ùå node_modules/ (dependencies)")
      console.log("   ‚ùå .quartz-cache/ (build cache)")

      console.log(`\nüéØ Target: ${this.config.publicRepoUrl}`)
      console.log("üìä Result: Clean source-only repository")

      console.log("\n" + "=".repeat(80))

      rl.question(
        "\nü§î Are you SURE you want to push to the public repository? (yes/NO): ",
        (answer) => {
          rl.close()
          if (answer.toLowerCase() === "yes") {
            this.log("üöÄ Proceeding with push to public repository...", "success")
            resolve()
          } else {
            this.log("‚ùå Push cancelled by user", "warning")
            process.exit(0)
          }
        },
      )
    })
  }

  private async waitForFastModeConfirmation(): Promise<void> {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    })

    return new Promise((resolve) => {
      console.log("\n" + "=".repeat(60))
      console.log("üöÄ FAST MODE SANITIZATION SUMMARY")
      console.log("=".repeat(60))

      console.log("\nüìã What will be done:")
      console.log("   ‚úÖ Include ONLY quartz/ and api/ directories")
      console.log("   ‚úÖ Include essential configuration files")
      console.log("   ‚úÖ Exclude ALL content, scripts, docs, and other files")
      console.log("   ‚úÖ Exclude ALL build artifacts and cache files")
      console.log("   ‚úÖ Use optimized git operations (--progress --no-verify)")

      console.log("\nüìÅ Files being included:")
      console.log("   ‚úÖ quartz/ (Quartz framework source code)")
      console.log("   ‚úÖ api/ (API-related files)")
      console.log("   ‚úÖ package.json & package-lock.json (dependencies)")
      console.log("   ‚úÖ quartz.config.ts & quartz.layout.ts (configuration)")
      console.log("   ‚úÖ tsconfig.json, globals.d.ts, index.d.ts (TypeScript)")
      console.log("   ‚úÖ README.md (documentation)")
      console.log("   ‚úÖ Configuration files (.gitignore, .prettierrc, etc.)")
      console.log("   ‚úÖ Build files (Dockerfile)")

      console.log("\nüìÅ Files being excluded:")
      console.log("   ‚ùå content/ (all your content)")
      console.log("   ‚ùå public/ (build artifacts)")
      console.log("   ‚ùå node_modules/ (dependencies)")
      console.log("   ‚ùå .quartz-cache/ (build cache)")
      console.log("   ‚ùå tests/ (test files)")
      console.log("   ‚ùå scripts/ (utility scripts)")
      console.log("   ‚ùå docs/ (documentation)")
      console.log("   ‚ùå All other directories and files")

      console.log(`\nüéØ Target: ${this.config.publicRepoUrl}`)
      console.log("üìä Result: Clean source-only repository")

      console.log("\n" + "=".repeat(60))

      rl.question("\nü§î Proceed with fast sanitization? (y/N): ", (answer) => {
        rl.close()
        if (answer.toLowerCase() === "y" || answer.toLowerCase() === "yes") {
          this.log("üöÄ Proceeding with fast sanitization...", "success")
          resolve()
        } else {
          this.log("‚ùå Sanitization cancelled by user", "warning")
          process.exit(0)
        }
      })
    })
  }
}

// CLI handling
async function main(): Promise<void> {
  const args = process.argv.slice(2)
  const dryRun = args.includes("--dry-run")
  const debug = args.includes("--debug")
  const fastMode = args.includes("--fast")

  if (args.includes("--help")) {
    console.log("Usage: npx tsx scripts/sanitize.ts [OPTIONS]")
    console.log("Options:")
    console.log("  --dry-run    Run sanitization without pushing")
    console.log("  --fast       Use fast mode (skip confirmation, optimized git ops)")
    console.log("  --debug      Enable debug output")
    console.log("  --help       Show this help message")
    process.exit(0)
  }

  if (debug) {
    console.log("Debug mode enabled")
  }

  if (fastMode) {
    console.log("Fast mode enabled - using optimized git operations")
  }

  const sanitizer = new RepositorySanitizer()
  await sanitizer.sanitizeAndPush(dryRun, fastMode)
}

// Run the script
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch((error) => {
    console.error("Sanitization failed:", error)
    process.exit(1)
  })
}

export { RepositorySanitizer }
