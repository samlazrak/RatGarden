{
  "version": 3,
  "sources": ["../../../../../../Users/samlazrak/Development/RatGarden/netlify/functions/gemini-assistant.ts"],
  "sourceRoot": "/var/folders/n9/6y8rmmyx34sb156z9jsxst9w0000gn/T/tmp-92320-axCJoM140peC",
  "sourcesContent": ["// Netlify function types\ninterface HandlerEvent {\n  httpMethod: string\n  body: string | null\n  path: string\n}\n\ninterface HandlerContext {\n  // Add any context properties as needed\n}\n\ninterface HandlerResponse {\n  statusCode: number\n  body?: string\n  headers?: Record<string, string | undefined>\n}\n\ntype Handler = (\n  event: HandlerEvent,\n  context: HandlerContext,\n) => Promise<HandlerResponse> | HandlerResponse\n\ninterface GeminiRequest {\n  text: string\n  feature: \"grammar\" | \"style\" | \"suggestions\" | \"completion\" | \"summarize\" | \"medical\"\n  context?: string\n}\n\ninterface GeminiResponse {\n  corrections?: Array<{\n    text: string\n    replacement: string\n    reason: string\n    type: string\n  }>\n  suggestions?: string[]\n  completion?: string\n  summary?: string\n  key_points?: string[]\n  score?: {\n    grammar: number\n    clarity: number\n    engagement: number\n  }\n  error?: string\n  raw_response?: string\n  feature?: string\n}\n\ninterface GeminiAPIResponse {\n  candidates?: Array<{\n    content: {\n      parts: Array<{\n        text: string\n      }>\n    }\n  }>\n}\n\nconst GEMINI_API_KEY = process.env.GEMINI_API_KEY\n\nexport const handler: Handler = async (event: HandlerEvent, context: HandlerContext) => {\n  // CORS headers\n  if (event.httpMethod === \"OPTIONS\") {\n    return {\n      statusCode: 200,\n      headers: {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"POST, OPTIONS\",\n        \"Access-Control-Allow-Headers\": \"Content-Type\",\n      },\n    }\n  }\n\n  if (event.httpMethod !== \"POST\") {\n    return {\n      statusCode: 405,\n      body: JSON.stringify({ error: \"Method not allowed\" }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    }\n  }\n\n  if (!GEMINI_API_KEY) {\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ error: \"Gemini API key not configured\" }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    }\n  }\n\n  try {\n    const { text, feature, context }: GeminiRequest = JSON.parse(event.body || \"{}\")\n\n    if (!text || !feature) {\n      return {\n        statusCode: 400,\n        body: JSON.stringify({ error: \"Missing required fields: text and feature\" }),\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Access-Control-Allow-Origin\": \"*\",\n        },\n      }\n    }\n\n    // Rate limiting and token optimization\n    const maxTokens = getMaxTokensForFeature(feature)\n    const model = getOptimalModel(feature, text.length)\n\n    let systemPrompt = getSystemPrompt(feature)\n    let userPrompt = buildUserPrompt(text, feature, context)\n\n    const response = await fetch(\n      `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          contents: [\n            {\n              role: \"user\",\n              parts: [\n                {\n                  text: `${systemPrompt}\\n\\n${userPrompt}`,\n                },\n              ],\n            },\n          ],\n          generationConfig: {\n            temperature: 0.1,\n            maxOutputTokens: maxTokens,\n            topP: 0.8,\n            topK: 40,\n          },\n        }),\n      },\n    )\n\n    if (!response.ok) {\n      throw new Error(`Gemini API error: ${response.status}`)\n    }\n\n    const data = (await response.json()) as GeminiAPIResponse\n\n    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {\n      throw new Error(\"Invalid response from Gemini API\")\n    }\n\n    const aiResponse = parseResponse(data.candidates[0].content.parts[0].text, feature)\n\n    return {\n      statusCode: 200,\n      body: JSON.stringify(aiResponse),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    }\n  } catch (error) {\n    console.error(\"Gemini Assistant error:\", error)\n    return {\n      statusCode: 500,\n      body: JSON.stringify({ error: \"Failed to process request\" }),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    }\n  }\n}\n\n// Token optimization functions\nfunction getMaxTokensForFeature(feature: string): number {\n  const tokenLimits: Record<string, number> = {\n    grammar: 300,\n    style: 400,\n    suggestions: 200,\n    completion: 500,\n    summarize: 300,\n    medical: 600, // Higher for medical content validation\n  }\n  return tokenLimits[feature] || 300\n}\n\nfunction getOptimalModel(feature: string, textLength: number): string {\n  // Use Gemini 1.5 Flash for simple tasks, Gemini 1.5 Pro for complex ones\n  if (feature === \"medical\" || textLength > 2000) {\n    return \"gemini-1.5-pro\"\n  }\n  return \"gemini-1.5-flash\" // Most cost-effective for simple tasks\n}\n\nfunction getSystemPrompt(feature: string): string {\n  const prompts: Record<string, string> = {\n    grammar: `You are a grammar and spelling expert. Provide corrections in JSON format with minimal tokens. Focus only on actual errors.`,\n    style: `You are a writing style expert. Provide style improvements in JSON format. Be concise and actionable.`,\n    suggestions: `You are a content strategist. Provide brief, actionable suggestions in JSON format.`,\n    completion: `You are a writing assistant. Continue the text naturally and concisely. Return JSON with completion.`,\n    summarize: `You are a summarization expert. Create concise summaries in JSON format.`,\n    medical: `You are a medical content validator. Check for accuracy, HIPAA compliance, and evidence-based claims. Return detailed analysis in JSON.`,\n  }\n  return prompts[feature] || prompts.grammar\n}\n\nfunction buildUserPrompt(text: string, feature: string, context: string = \"\"): string {\n  let prompt = \"\"\n\n  switch (feature) {\n    case \"grammar\":\n      prompt = `Check the following text for grammar and spelling errors. Provide corrections in this JSON format:\n{\n  \"corrections\": [{\"text\": \"error\", \"replacement\": \"correction\", \"reason\": \"explanation\", \"type\": \"grammar\"}],\n  \"suggestions\": [\"general improvement suggestions\"],\n  \"score\": {\"grammar\": 85, \"clarity\": 90, \"engagement\": 80}\n}\n\nText: ${text}`\n      break\n\n    case \"style\":\n      prompt = `Analyze the writing style of this text and suggest improvements. Format response as JSON:\n{\n  \"corrections\": [{\"text\": \"weak phrase\", \"replacement\": \"stronger phrase\", \"reason\": \"explanation\", \"type\": \"style\"}],\n  \"suggestions\": [\"style improvement suggestions\"],\n  \"score\": {\"grammar\": 85, \"clarity\": 90, \"engagement\": 80}\n}\n\nText: ${text}`\n      break\n\n    case \"suggestions\":\n      prompt = `Provide content suggestions for this text. Format as JSON:\n{\n  \"suggestions\": [\"suggestion 1\", \"suggestion 2\", \"suggestion 3\"]\n}\n\nText: ${text}`\n      break\n\n    case \"completion\":\n      prompt = `Continue this text naturally. Return JSON:\n{\n  \"completion\": \"your continuation here\"\n}\n\nText: ${text}`\n      break\n\n    case \"summarize\":\n      prompt = `Summarize this text concisely. Return JSON:\n{\n  \"summary\": \"your summary here\",\n  \"key_points\": [\"point 1\", \"point 2\", \"point 3\"]\n}\n\nText: ${text}`\n      break\n\n    case \"medical\":\n      prompt = `Validate this medical content for accuracy and compliance. Return JSON:\n{\n  \"corrections\": [{\"text\": \"inaccurate statement\", \"replacement\": \"accurate statement\", \"reason\": \"explanation\", \"type\": \"medical\"}],\n  \"suggestions\": [\"compliance suggestions\"],\n  \"score\": {\"accuracy\": 85, \"compliance\": 90, \"clarity\": 80}\n}\n\nText: ${text}`\n      break\n\n    default:\n      prompt = `Analyze this text and provide feedback. Format as JSON with corrections, suggestions, and scores.\n\nText: ${text}`\n  }\n\n  if (context) {\n    prompt = `${prompt}\\n\\nContext: ${context}`\n  }\n\n  return prompt\n}\n\nfunction parseResponse(responseText: string, feature: string): GeminiResponse {\n  try {\n    // Try to parse as JSON first\n    return JSON.parse(responseText)\n  } catch (error) {\n    // Try to extract JSON from markdown code blocks\n    const jsonMatch = responseText.match(/```(?:json)?\\s*(\\{[\\s\\S]*?\\})\\s*```/)\n    if (jsonMatch) {\n      try {\n        return JSON.parse(jsonMatch[1])\n      } catch (jsonError) {\n        console.error(\"Failed to parse JSON from markdown:\", jsonError)\n      }\n    }\n\n    // Fallback to structured response\n    return {\n      error: \"Invalid JSON response\",\n      raw_response: responseText,\n      feature,\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": ["context"]
}
